#!/usr/bin/env python3
"""
Code originally from GRIP
"""
import cv2
import numpy
import freenect
from itertools import combinations
from frame_convert2 import *


DISTANCE_LIFT_TAPE = 10.25  #outside edges

class TooMuchInterferenceException(Exception):
    """
    The Exception raised when there is no goal in the image
    """
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class GoalNotFoundException(Exception):
    """
    The Exception raised when there is no goal in the image
    """
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def read_kinect_image(ir=False):
    if not ir:
        return video_cv(freenect.sync_get_video()[0])
    else:
        ir_feed = freenect.sync_get_video(0, format=freenect.VIDEO_IR_8BIT)
        ir_feed = ir_feed[1], ir_feed[0]
        # depth_feed = freenect.sync_get_depth()
        # ir_feed = freenect.sync_get_video(0, format=freenect.VIDEO_IR_8BIT)
        # cv2.imwrite("temp_video.png", ir_feed[1])
        depth_accumulator = freenect.sync_get_depth()[0]
        real_depth = numpy.copy(depth_accumulator)
        depth_accumulator[depth_accumulator > 2046] = 0
        for i in range(10):
            # print(depth_accumulator)
            depth_accumulator = combine_depth_frames(depth_accumulator, freenect.sync_get_depth()[0])
        depth_accumulator[depth_accumulator > 0] = 255
        # print(ir_feed)
        # depth_accumulator = depth_accumulator.astype()
        ir_feed = numpy.bitwise_and(depth_accumulator.astype(numpy.uint8), numpy.array(ir_feed[1])).astype(numpy.uint8)
        # cv2.imwrite("thing.png", frame_convert.pretty_depth_cv(ir_feed))
        process_frame = pretty_depth_cv(ir_feed)
        return process_frame, real_depth

def combine_depth_frames(frame1, frame2):
    frame2[frame2 > 2046] = 0
    return numpy.bitwise_or(frame1, frame2)

def gaussian_blur(src):
    radius = 3
    ksize = int(6 * round(radius) + 1)
    return cv2.GaussianBlur(src, (ksize, ksize), round(radius))

def binary_threshold(src):
    return cv2.threshold(src, 20, 255, cv2.THRESH_BINARY)[1]

def hsv_threshold(src):
    hue, sat, val = [(0, 180), (0, 0), (128, 255)]
    out = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)
    return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

def get_contours(src):
    mode = cv2.RETR_EXTERNAL
    method = cv2.CHAIN_APPROX_SIMPLE
    im2, contours, hierarchy = cv2.findContours(src, mode=mode, method=method)
    print("len of contours:", len(contours))
    return contours

def filter_contours(input_contours):
    output = []
    for contour in input_contours:
        x,y,w,h = cv2.boundingRect(contour)
        if w < 0 or w > 1000:
            continue
        if h < 0 or h > 1000:
            continue
        area = cv2.contourArea(contour)
        if area < 100:
            continue
        if cv2.arcLength(contour, True) < 0:
            continue
        hull = cv2.convexHull(contour)
        solid = 100 * area / cv2.contourArea(hull)
        if solid < 0 or solid > 100:
            continue
        if len(contour) < 0 or len(contour) > 200:
            continue
        ratio = w / h
        if ratio < 0 or ratio > 0.5:
            continue
        output.append(contour)
    return output

def find_hulls(input_contours):
    return [cv2.convexHull(contour) for contour in input_contours]

def sort_hulls(input_hulls):
    pass

def get_corners_from_contours(contours, corner_amount=4):
    """
    Finds four corners from a list of points on the goal
    epsilon - the minimum side length of the polygon generated by the corners

    Parameters:
        :param: `contours` - a numpy array of points (opencv contour) of the
                             points to get corners from
        :param: `corner_amount` - the number of corners to find
    """
    coefficient = .05
    while True:
        # print(contours)
        epsilon = coefficient * cv2.arcLength(contours, True)
        # epsilon =
        print("epsilon:", epsilon)
        poly_approx = cv2.approxPolyDP(contours, epsilon, True)
        hull = cv2.convexHull(poly_approx)
        if len(hull) == corner_amount:
            return hull
        else:
            if len(hull) > corner_amount:
                coefficient += .001
            else:
                coefficient -= .001

def get_center(corners):
    """
    Gets center pixel of object given corner pixels
    Parameters:
        :param: `corners` - a numpy array of corner pixels
    Returns:
        A numpy array of size 2 with the x and y coords of the center
    """
    center = numpy.array([0, 0])
    for i in range(len(corners)):
        center[0] += corners[i][0][0]
        center[1] += corners[i][0][1]
    center[0] /= len(corners)
    center[1] /= len(corners)
    return center

def sort_corners(corners, center):
    """
    Sorts the corners in clockwise format around the center

    Parameters:
        :param: `corners` - a numpy array of coordinates of corners of the goal
        :param: `center` - a numpy array of size 2 with the center in it
    """
    top = []
    bot = []

    for i in range(len(corners)):
        if(corners[i][0][1] < center[1]):
            top.append(corners[i])
        else:
            bot.append(corners[i])

    tl = top[1] if top[0][0][0] > top[1][0][0] else top[0]
    tr = top[0] if top[0][0][0] > top[1][0][0] else top[1]
    bl = bot[1] if bot[0][0][0] > bot[1][0][0] else bot[0]
    br = bot[0] if bot[0][0][0] > bot[1][0][0] else bot[1]
    return numpy.array([tl, tr, br, bl], numpy.float32)

def sort_hulls_by_corners(corner_set):
    print("corner_set[0][0][0][0]:", corner_set[0][0][0][0])
    return sorted(range(len(corner_set)), key=lambda i: corner_set[i][0][0][0])

def filter_hulls_by_y_position(corner_set, offset=50):
    # print(corner_set)
    median_y = numpy.median([corner_set[i][0][0][0] for i in range(len(corner_set))])
    return [i for i, corner in enumerate(corner_set) if abs(corner[0][0][0] - median_y) > offset]

def distance(p1, p2):
    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))

def get_position_from_src(src):
    blur = gaussian_blur(src)

    threshold = binary_threshold(blur)
    cv2.imwrite("threshold.png", threshold)

    contours = get_contours(threshold)
    filtered_contours = filter_contours(contours)
    contour_drawn = cv2.cvtColor(numpy.copy(threshold), cv2.COLOR_GRAY2BGR)
    cv2.drawContours(contour_drawn, filtered_contours, -1, (0,255,0), 3)
    cv2.imwrite("contoured.png", contour_drawn)

    hulls = find_hulls(filtered_contours)
    sorted_corners_for_each_hull = []

    
    # print(hulls)

    for hull in hulls:
        corners = get_corners_from_contours(hull)
        sorted_corners_for_each_hull.append(sort_corners(corners, get_center(corners)))

    for i in filter_hulls_by_y_position(sorted_corners_for_each_hull)[::-1]:
        del sorted_corners_for_each_hull[i]


    if len(sorted_corners_for_each_hull) < 2:
        raise GoalNotFoundException("yo no goals")
    elif len(sorted_corners_for_each_hull) > 4:
        raise TooMuchInterferenceException("why is everything reflective :/")

    order_of_hulls = sort_hulls_by_corners(sorted_corners_for_each_hull)
    print("order of hulls:", order_of_hulls)
    print("corners:", sorted_corners_for_each_hull)

    if len(sorted_corners_for_each_hull) == 3:
        combos = combinations((0, 1, 2), 2)
        pair = min((0, 1, 2), key=lambda i: distance(sorted_corners_for_each_hull[combos[i][0]][0][0], sorted_corners_for_each_hull[combos[i][1]][0][0]))
        sorted_corners_for_each_hull = [sorted_corners_for_each_hull[pair[0]], sorted_corners_for_each_hull[pair[1]]]
    elif len(sorted_corners_for_each_hull) == 4:
        combos = combinations((0, 1, 2, 3), 2)
        pair1 = min(range(len(combos)), key=lambda i: distance(sorted_corners_for_each_hull[combos[i][0]][0][0], sorted_corners_for_each_hull[combos[i][1]][0][0]))
        pair2 = len(combos) - pair1 - 1
        size = lambda i: cv2.contourArea(filter_contours[order_of_hulls[i]])
        if size(pair1[0]) + size(pair1[1]) > size(pair2[0]) + size(pair2[1]):
            sorted_corners_for_each_hull = [sorted_corners_for_each_hull[pair1[0]], sorted_corners_for_each_hull[pair1[1]]]
        else:
            sorted_corners_for_each_hull = [sorted_corners_for_each_hull[pair2[0]], sorted_corners_for_each_hull[pair2[1]]]
    corner_set1, corner_set2 = sorted_corners_for_each_hull[0], sorted_corners_for_each_hull[1]
    print("corner set 1:", corner_set1)
    print("corner set 2:", corner_set2)
    final_coordinates = [[int((corner_set1[0][0][0] + corner_set1[3][0][0]) / 2), int((corner_set1[0][0][1] + corner_set1[3][0][1]) / 2)],
                         [int((corner_set2[1][0][0] + corner_set2[2][0][0]) / 2), int((corner_set2[1][0][1] + corner_set2[2][0][1]) / 2)]]

    # print(len(hull_position))
    return final_coordinates

def find_turning_angle(to_target_edge, left_distance, right_distance):
    """
    Params:
    to_target_edget = angle from front of robot to the nearest tape
    left_distance and right_distance = distance from robot to left/right tape
    """
    sides = (left_distance ** 2 + right_distance ** 2 - DISTANCE_LIFT_TAPE ** 2) / 2 * left_distance * right_distance
    theta = numpy.arccos(sides)
    return to_target_edge + theta/2

def main():
    # while True:
    # image, depth = read_kinect_image(ir=True)
    image = cv2.cvtColor(cv2.imread("morepotato.png"), cv2.COLOR_BGR2GRAY)
    # rgb = read_kinect_image(ir=False)
    # image = cv2.imread("potato.png")
    # cv2.imwrite("morepotato.png", image)
    # print(image)
    # contoured = numpy.copy(image)
    print(get_position_from_src(image))
    # cv2.drawContours(contoured, get_position_from_src(image), -1, (0, 254, 0))
    # cv2.imwrite("potato.png", contoured)
    # cv2.imshow('potato chip', get_position_from_src(image))
    # cv2.waitKey(10000)
    pass

if __name__ == '__main__':
    main()
